#.\app.py

import eel
import os
import json
from urllib.parse import quote
import shlex

# --- NOSSAS NOVAS IMPORTAÇÕES ---
# Importa os módulos que contêm a lógica desacoplada
import database_handler as db
import processing_logic as proc

# ==============================================================================
# --- CONFIGURAÇÃO ---
# ==============================================================================
TAGS_FILE = "tags.txt"
ALLOWED_TAGS = set()

def load_allowed_tags():
    """Lê o arquivo tags.txt e o carrega em um set para busca rápida."""
    global ALLOWED_TAGS
    if not os.path.exists(TAGS_FILE):
        print(f"AVISO: '{TAGS_FILE}' não encontrado. Todas as tags serão exibidas.")
        return
    try:
        with open(TAGS_FILE, 'r', encoding='utf-8') as f:
            ALLOWED_TAGS = {line.strip() for line in f if line.strip()}
        print(f"Carregadas {len(ALLOWED_TAGS)} tags permitidas de '{TAGS_FILE}'.")
    except Exception as e:
        print(f"ERRO ao ler '{TAGS_FILE}': {e}")

# ==============================================================================
# --- FUNÇÕES EXPOSTAS AO JAVASCRIPT ---
# ==============================================================================

@eel.expose
def get_all_actresses():
    """Delega a busca por atrizes para o database_handler."""
    actresses = db.get_actresses()
    # Prepara os caminhos para uso em URL
    for actress in actresses:
        if actress.get('file_path'):
            actress['file_path'] = quote(actress['file_path'].replace(os.path.sep, '/'))
    return actresses

@eel.expose
def get_videos_page(actress_name, page_number=1):
    """Delega a busca paginada de vídeos para o database_handler."""
    response = db.get_paged_videos_by_actress(actress_name, page_number)
    
    # Processa os resultados para o frontend
    for video in response['videos']:
        video['main_tags'] = video.pop('all_tags_with_scores')
        if video['main_tags'] and ALLOWED_TAGS:
            video_tags_with_scores = video['main_tags'].split('|||')
            filtered_tags = [item for item in video_tags_with_scores if item.split(':')[0] in ALLOWED_TAGS]
            video['main_tags'] = "|||".join(filtered_tags)
        if video.get('file_path'):
            video['file_path'] = quote(video['file_path'].replace(os.path.sep, '/'))
            
    return response

# [NOVO] Função de processamento agora delega a lógica pesada
@eel.expose
def process_video(video_id, fps=1.0, similarity_threshold=0.4, batch_size=32):
    
    def progress_callback(vid, status, progress):
        """Função que será passada para o módulo de processamento para enviar updates."""
        try:
            eel.update_process_status(vid, status, progress)()
            eel.sleep(0.01) # Permite que a mensagem seja enviada
        except Exception:
            # Ignora erros se a interface for fechada durante o processamento
            pass

    try:
        # Busca o caminho do vídeo usando o handler do DB
        video_path = db.get_video_path(video_id)
        if not video_path or not os.path.exists(video_path):
            raise Exception(f"Caminho do vídeo não encontrado ou inválido: {video_path}")

        # Chama a função principal do pipeline de processamento
        cenas_agrupadas = proc.run_video_processing_pipeline(
            video_path=video_path,
            fps=fps,
            similarity_threshold=similarity_threshold,
            batch_size=batch_size,
            video_id=video_id,
            progress_callback=progress_callback
        )
        
        progress_callback(video_id, "Salvando no banco de dados...", 95)
        # Salva os resultados usando o handler do DB
        db.save_scenes_to_db(video_id, cenas_agrupadas)
        
        progress_callback(video_id, "Concluído!", 100)
        eel.process_finished(video_id, True)()

    except Exception as e:
        print(f"ERRO no processamento do video {video_id}: {e}")
        progress_callback(video_id, f"Erro: {e}", -1)
        eel.process_finished(video_id, False)()


# Funções de busca e outras delegam para o database_handler
@eel.expose
def get_scenes_for_video(video_id):
    return db.get_scenes_for_video(video_id)

@eel.expose
def get_all_tags_for_autocomplete():
    return json.dumps(sorted(list(ALLOWED_TAGS)))

@eel.expose
def search_videos_by_tags(actress_name, search_query):
    # A lógica de busca real pode ser movida para o database_handler também
    # Por enquanto, mantemos aqui para simplicidade
    response = db.search_videos(actress_name, search_query) # Supondo que você criou essa função no db handler
    for video in response['videos']:
        # ... processamento de tags e caminhos ...
        pass
    return response


# ==============================================================================
# --- INICIALIZAÇÃO DA APLICAÇÃO ---
# ==============================================================================
if __name__ == "__main__":
    load_allowed_tags()
    
    # Define a pasta 'web' como a raiz da aplicação.
    eel.init('web')
    
    print("Iniciando 'Pulser Edits' (Desacoplado)...")
    
    try:
        eel.start('home.html', size=(1400, 900))
    except Exception as e:
        print(f"ERRO ao iniciar o Eel. Verifique se o Chrome/Edge está instalado. Erro: {e}")

--------

#.\concatenar.py

import os

# extensões que você quer juntar
EXTENSOES = {".hml", ".py", ".js", ".css"}

# pasta base (troque se precisar)
PASTA_BASE = "."

# arquivo final
ARQUIVO_SAIDA = "arquivos_concatenados.txt"


def concatenar_arquivos(pasta_base, arquivo_saida):
    with open(arquivo_saida, "w", encoding="utf-8") as saida:
        for root, _, files in os.walk(pasta_base):
            for file in files:
                _, ext = os.path.splitext(file)
                if ext.lower() in EXTENSOES:
                    caminho = os.path.join(root, file)

                    # escreve cabeçalho com caminho
                    saida.write(f"#{caminho}\n\n")

                    try:
                        with open(caminho, "r", encoding="utf-8", errors="ignore") as f:
                            conteudo = f.read()
                            saida.write(conteudo.strip())
                    except Exception as e:
                        saida.write(f"## Erro ao ler {caminho}: {e}")

                    # separador
                    saida.write("\n\n--------\n\n")


if __name__ == "__main__":
    concatenar_arquivos(PASTA_BASE, ARQUIVO_SAIDA)
    print(f"Concatenação concluída! Arquivo salvo em: {ARQUIVO_SAIDA}")

--------

#.\construir_banco_de_cenas.py

import os
import sqlite3
import json
from tqdm import tqdm

# ==============================================================================
# --- CONFIGURAÇÃO ---
# ==============================================================================
DATA_ROOT_FOLDER = os.path.join("web", "videos")
DB_FILE = "cenas_database.db"

# ==============================================================================
# --- FUNÇÕES ---
# ==============================================================================
def setup_database(db_path):
    if os.path.exists(db_path): os.remove(db_path)
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute("PRAGMA foreign_keys = ON;")
    cursor.execute("CREATE TABLE videos (video_id INTEGER PRIMARY KEY, video_name TEXT NOT NULL UNIQUE, actress TEXT, file_path TEXT)")
    cursor.execute("CREATE TABLE scenes (scene_id INTEGER PRIMARY KEY, video_id INTEGER NOT NULL, scene_number INTEGER NOT NULL, start_time REAL NOT NULL, end_time REAL NOT NULL, duration REAL NOT NULL, FOREIGN KEY (video_id) REFERENCES videos(video_id))")
    cursor.execute("CREATE TABLE tags (tag_id INTEGER PRIMARY KEY, tag_name TEXT NOT NULL UNIQUE)")
    cursor.execute("CREATE TABLE scene_tags (scene_id INTEGER NOT NULL, tag_id INTEGER NOT NULL, score REAL NOT NULL, PRIMARY KEY (scene_id, tag_id), FOREIGN KEY (scene_id) REFERENCES scenes(scene_id) ON DELETE CASCADE, FOREIGN KEY (tag_id) REFERENCES tags(tag_id))")
    conn.commit()
    print("Nova estrutura de banco de dados criada.")
    return conn

def build_scene_database():
    conn = setup_database(DB_FILE)
    cursor = conn.cursor()

    try:
        actress_folders = [d for d in os.listdir(DATA_ROOT_FOLDER) if os.path.isdir(os.path.join(DATA_ROOT_FOLDER, d))]
    except FileNotFoundError:
        print(f"ERRO: A pasta '{DATA_ROOT_FOLDER}' não foi encontrada.")
        return

    video_extensions = ('.mp4', '.mkv', '.mov', '.webm', '.avi', '.wmv', '.mpg')

    for actress_name in tqdm(actress_folders, desc="Processando Atrizes"):
        actress_folder_path = os.path.join(DATA_ROOT_FOLDER, actress_name)
        video_files = [f for f in os.listdir(actress_folder_path) if f.lower().endswith(video_extensions)]

        for video_filename in tqdm(video_files, desc=f"  Vídeos de {actress_name}", leave=False):
            base_video_name, _ = os.path.splitext(video_filename)
            json_filename = f"{base_video_name}_cenas.json"
            json_path = os.path.join(actress_folder_path, json_filename)
            if not os.path.exists(json_path):
                continue

            path_to_save_in_db = os.path.join("videos", actress_name, video_filename).replace(os.path.sep, '/')
            cursor.execute("INSERT OR IGNORE INTO videos (video_name, actress, file_path) VALUES (?, ?, ?)", 
                           (base_video_name, actress_name, path_to_save_in_db))
            
            cursor.execute("SELECT video_id FROM videos WHERE video_name = ?", (base_video_name,))
            video_id = cursor.fetchone()[0]
            
            with open(json_path, 'r', encoding='utf-8') as f:
                try: scenes_data = json.load(f)
                except json.JSONDecodeError: continue

            for scene in scenes_data:
                cursor.execute("INSERT INTO scenes (video_id, scene_number, start_time, end_time, duration) VALUES (?, ?, ?, ?, ?)", (video_id, scene.get('cena_n'), scene.get('start_time'), scene.get('end_time'), scene.get('duration')))
                scene_id = cursor.lastrowid
                for tag_name_original, score in scene.get('tags_principais', {}).items():
                    
                    # [CORREÇÃO CRUCIAL] Padroniza a tag aqui!
                    tag_name_standardized = tag_name_original.replace(' ', '_')

                    cursor.execute("INSERT OR IGNORE INTO tags (tag_name) VALUES (?)", (tag_name_standardized,))
                    cursor.execute("SELECT tag_id FROM tags WHERE tag_name = ?", (tag_name_standardized,))
                    tag_id_result = cursor.fetchone()
                    if tag_id_result:
                        tag_id = tag_id_result[0]
                        cursor.execute("INSERT INTO scene_tags (scene_id, tag_id, score) VALUES (?, ?, ?)", (scene_id, tag_id, score))
    
    conn.commit()
    conn.close()
    print("\nBanco de dados reconstruído com tags padronizadas (espaços -> '_').")

if __name__ == "__main__":
    build_scene_database()

--------

#.\converter.py

import os
import subprocess
from tqdm import tqdm

# ==============================================================================
# --- CONFIGURAÇÃO ---
# ==============================================================================

# A pasta raiz que contém as subpastas de cada atriz com os vídeos.
VIDEO_ROOT_FOLDER = os.path.join("web", "videos")

# Formatos a serem convertidos. Adicione outros se necessário.
FORMATS_TO_CONVERT = ('.wmv', '.avi', '.mkv', '.mpg', '.mpeg', '.flv', '.mov')

# ==============================================================================
# --- FUNÇÃO PRINCIPAL DE CONVERSÃO ---
# ==============================================================================

def convert_videos_to_mp4():
    """
    Varre as pastas de vídeo, converte formatos antigos para MP4 usando a GPU,
    e deleta os arquivos originais.
    """
    print(f"--- Iniciando a conversão de vídeos em '{VIDEO_ROOT_FOLDER}' para MP4 ---")

    videos_to_convert = []
    # Encontra todos os arquivos que precisam de conversão
    for root, _, files in os.walk(VIDEO_ROOT_FOLDER):
        for file in files:
            if file.lower().endswith(FORMATS_TO_CONVERT):
                videos_to_convert.append(os.path.join(root, file))

    if not videos_to_convert:
        print("Nenhum vídeo para converter. Todos já estão em formato moderno ou a pasta está vazia.")
        return

    print(f"Encontrados {len(videos_to_convert)} vídeos para converter.")

    success_count = 0
    fail_count = 0

    for video_path in tqdm(videos_to_convert, desc="Convertendo vídeos"):
        base_path, _ = os.path.splitext(video_path)
        output_path = f"{base_path}.mp4"
        
        # Comando de conversão com aceleração por GPU (NVENC)
        # '-c:v h264_nvenc' -> Encoder de vídeo da Nvidia
        # '-preset fast' -> Bom equilíbrio de velocidade/qualidade
        # '-c:a aac' -> Codec de áudio padrão e compatível
        command = [
            'ffmpeg', '-y', '-hide_banner', '-loglevel', 'error',
            '-i', video_path,
            '-c:v', 'h264_nvenc',
            '-preset', 'fast',
            '-c:a', 'aac',
            '-b:a', '192k',
            output_path
        ]

        try:
            # Executa a conversão
            subprocess.run(command, check=True)
            
            # Se a conversão foi bem-sucedida, deleta o original
            os.remove(video_path)
            
            # [CRUCIAL] Renomeia o arquivo JSON correspondente, se existir
            original_json_path = f"{base_path}_cenas.json"
            new_json_path = f"{base_path}.mp4_cenas.json" # Temporário
            final_json_path = f"{base_path}_cenas.json" # O nome final correto

            if os.path.exists(original_json_path):
                # Renomeia para um nome temporário para evitar conflitos se o .mp4 já existia
                os.rename(original_json_path, new_json_path)
                # Renomeia de volta para o nome final, agora que o original se foi
                os.rename(new_json_path, final_json_path)

            success_count += 1
        except subprocess.CalledProcessError:
            tqdm.write(f"  ERRO: Falha ao converter '{os.path.basename(video_path)}'. Pode ser um codec não suportado pela GPU.")
            # Opcional: Adicionar um fallback para CPU aqui se quiser ser exaustivo
            fail_count += 1
        except Exception as e:
            tqdm.write(f"  ERRO inesperado com '{os.path.basename(video_path)}': {e}")
            fail_count += 1
            
    print("\n--- Conversão Concluída ---")
    print(f"✅ Convertidos com sucesso: {success_count}")
    print(f"❌ Falhas: {fail_count}")

if __name__ == "__main__":
    convert_videos_to_mp4()

--------

#.\database_handler.py

import sqlite3
import os

DB_FILE = "cenas_database.db"
PAGE_SIZE = 20

def get_connection():
    """Cria e retorna uma conexão com o banco de dados."""
    conn = sqlite3.connect(DB_FILE, timeout=10.0)
    conn.row_factory = sqlite3.Row
    return conn

def get_actresses():
    """Busca a lista de todas as atrizes."""
    with get_connection() as conn:
        cursor = conn.cursor()
        query = "SELECT actress, file_path FROM videos WHERE actress IS NOT NULL AND actress != '' GROUP BY actress ORDER BY actress"
        cursor.execute(query)
        return [dict(row) for row in cursor.fetchall()]

def get_paged_videos_by_actress(actress_name, page_number):
    """Busca uma página de vídeos para uma atriz, incluindo status de processamento e tags."""
    with get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM videos WHERE actress = ?", (actress_name,))
        total_videos = cursor.fetchone()[0]
        total_pages = (total_videos + PAGE_SIZE - 1) // PAGE_SIZE
        offset = (page_number - 1) * PAGE_SIZE
        
        query = """
        SELECT v.video_id, v.video_name, v.file_path,
               (CASE WHEN COUNT(s.scene_id) > 0 THEN 1 ELSE 0 END) as has_scenes,
               (SELECT GROUP_CONCAT(t.tag_name || ':' || printf("%.2f", top_tags.avg_score), '|||')
                FROM (SELECT st.tag_id, AVG(st.score) as avg_score FROM scenes s JOIN scene_tags st ON s.scene_id = st.scene_id WHERE s.video_id = v.video_id GROUP BY st.tag_id ORDER BY avg_score DESC) AS top_tags
                JOIN tags t ON top_tags.tag_id = t.tag_id) AS all_tags_with_scores
        FROM videos v LEFT JOIN scenes s ON v.video_id = s.video_id
        WHERE v.actress = ? GROUP BY v.video_id ORDER BY v.video_name LIMIT ? OFFSET ?
        """
        cursor.execute(query, (actress_name, PAGE_SIZE, offset))
        videos = [dict(row) for row in cursor.fetchall()]
        
        return {"videos": videos, "currentPage": page_number, "totalPages": total_pages}

def get_video_path(video_id):
    """Busca o caminho de um vídeo específico."""
    with get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT file_path FROM videos WHERE video_id = ?", (video_id,))
        result = cursor.fetchone()
        return result['file_path'] if result else None

def save_scenes_to_db(video_id, scenes_data):
    """Salva os dados de cenas processadas no banco de dados."""
    with get_connection() as conn:
        cursor = conn.cursor()
        # Limpa dados antigos para este vídeo
        cursor.execute("DELETE FROM scene_tags WHERE scene_id IN (SELECT scene_id FROM scenes WHERE video_id = ?)", (video_id,))
        cursor.execute("DELETE FROM scenes WHERE video_id = ?", (video_id,))
        
        for scene in scenes_data:
            cursor.execute("INSERT INTO scenes (video_id, scene_number, start_time, end_time, duration) VALUES (?, ?, ?, ?, ?)",
                           (video_id, scene.get('cena_n'), scene.get('start_time'), scene.get('end_time'), scene.get('duration')))
            scene_id = cursor.lastrowid
            for tag_name, score in scene.get('tags_principais', {}).items():
                cursor.execute("INSERT OR IGNORE INTO tags (tag_name) VALUES (?)", (tag_name,))
                cursor.execute("SELECT tag_id FROM tags WHERE tag_name = ?", (tag_name,))
                tag_id = cursor.fetchone()[0]
                cursor.execute("INSERT INTO scene_tags (scene_id, tag_id, score) VALUES (?, ?, ?)", (scene_id, tag_id, score))
        conn.commit()

# ... (Você pode adicionar as funções de busca por tag aqui também)

--------

#.\processing_logic.py

import os
import subprocess
import shutil
import huggingface_hub
import numpy as np
import onnxruntime as rt
import pandas as pd
from PIL import Image
import re
import torch

# ==============================================================================
# --- INICIALIZAÇÃO GLOBAL DO MODELO DE IA ---
# ==============================================================================
# Esta instância global será compartilhada por todas as chamadas de processamento,
# evitando que o modelo seja recarregado da memória a cada vídeo.
PREDICTOR_GLOBAL = None

# ==============================================================================
# --- CLASSE PREDICTOR E FUNÇÕES AUXILIARES DE IA ---
# ==============================================================================

# Definições auxiliares
kaomojis = ["0_0", "(o)_(o)", "+_+", "+_-", "._.", "<o>_<o>", "<|>_<|>", "=_=", ">_<", "3_3", "6_9", ">_o", "@_@", "^_^", "o_o", "u_u", "x_x", "|_|", "||_||"]

def load_labels(dataframe):
    name_series = dataframe["name"].map(lambda x: x.replace("_", " ") if x not in kaomojis else x)
    tag_names = name_series.tolist()
    # Para esta lógica, só precisamos dos nomes das tags.
    # Se precisar de categorias no futuro, elas podem ser retornadas aqui.
    return tag_names

class Predictor:
    def __init__(self):
        self.model = None
        self.tag_names = None
        self.model_target_size = None
        self.last_loaded_repo = None

    def load_model(self, model_repo="SmilingWolf/wd-swinv2-tagger-v3"):
        if self.last_loaded_repo == model_repo:
            return
        
        print(f"\nCarregando modelo de tagging: {model_repo}...")
        # Baixa os arquivos do Hugging Face Hub
        csv_path = huggingface_hub.hf_hub_download(model_repo, "selected_tags.csv")
        model_path = huggingface_hub.hf_hub_download(model_repo, "model.onnx")
        
        tags_df = pd.read_csv(csv_path)
        self.tag_names = load_labels(tags_df)
        
        # Define o provedor de execução (GPU se disponível, senão CPU)
        providers = ['CUDAExecutionProvider'] if torch.cuda.is_available() else ['CPUExecutionProvider']
        self.model = rt.InferenceSession(model_path, providers=providers)
        
        _, height, _, _ = self.model.get_inputs()[0].shape
        self.model_target_size = height
        self.last_loaded_repo = model_repo
        print(f"Modelo de tagging '{model_repo}' carregado com sucesso no dispositivo {'GPU' if 'CUDAExecutionProvider' in providers else 'CPU'}.")

    def prepare_image(self, image):
        image = image.convert("RGB")
        max_dim = max(image.size)
        padded_image = Image.new("RGB", (max_dim, max_dim), (255, 255, 255))
        padded_image.paste(image, ((max_dim - image.size[0]) // 2, (max_dim - image.size[1]) // 2))
        
        if max_dim != self.model_target_size:
            padded_image = padded_image.resize((self.model_target_size, self.model_target_size), Image.BICUBIC)
            
        image_array = np.asarray(padded_image, dtype=np.float32)[:, :, ::-1]
        return np.expand_dims(image_array, axis=0)

    def predict_batch(self, images, general_thresh=0.35):
        if not self.model:
            raise Exception("Modelo não carregado. Chame load_model() primeiro.")
            
        batch_array = np.vstack([self.prepare_image(img) for img in images])
        input_name = self.model.get_inputs()[0].name
        label_name = self.model.get_outputs()[0].name
        
        preds_batch = self.model.run([label_name], {input_name: batch_array})[0]
        
        batch_results = []
        for preds in preds_batch:
            labels = list(zip(self.tag_names, preds.astype(float)))
            res = {name: float(score) for name, score in labels if score > general_thresh}
            batch_results.append(res)
        return batch_results

# ==============================================================================
# --- FUNÇÕES DO PIPELINE DE PROCESSAMENTO ---
# ==============================================================================

def extrair_frames(caminho_video, diretorio_saida, fps, video_id, progress_callback):
    progress_callback(video_id, "Extraindo frames...", 5)
    os.makedirs(diretorio_saida, exist_ok=True)
    caminho_saida_frames = os.path.join(diretorio_saida, 'frame_%06d.png')
    comando = ['ffmpeg', '-y', '-i', caminho_video, '-vf', f'fps={fps}', '-hide_banner', '-loglevel', 'error', caminho_saida_frames]
    try:
        subprocess.run(comando, check=True, capture_output=True, text=True)
        num_frames = len([f for f in os.listdir(diretorio_saida) if f.endswith('.png')])
        progress_callback(video_id, f"{num_frames} frames extraídos.", 20)
        return num_frames
    except subprocess.CalledProcessError as e:
        raise Exception(f"FFmpeg falhou ao extrair frames: {e.stderr}")
    except Exception as e:
        raise Exception(f"Erro inesperado na extração de frames: {e}")

def gerar_tags_para_frames(predictor, pasta_frames, total_frames, batch_size, video_id, progress_callback):
    results = {}
    img_files = sorted([f for f in os.listdir(pasta_frames) if f.lower().endswith(('.png', '.jpg'))])
    if not img_files:
        return None

    processed_frames = 0
    for i in range(0, len(img_files), batch_size):
        batch_file_names = img_files[i:i+batch_size]
        batch_images = []
        for img_file in batch_file_names:
            try:
                # Garante que a imagem seja fechada após o uso
                with Image.open(os.path.join(pasta_frames, img_file)) as image:
                    batch_images.append(image.copy())
            except Exception:
                batch_images.append(None)
        
        valid_images = [img for img in batch_images if img is not None]
        if not valid_images:
            processed_frames += len(batch_file_names)
            continue
            
        try:
            batch_tags = predictor.predict_batch(valid_images)
            valid_file_names = [name for name, img in zip(batch_file_names, batch_images) if img is not None]
            for file_name, tags in zip(valid_file_names, batch_tags):
                results[file_name] = tags
                
            processed_frames += len(batch_file_names)
            progress = 20 + int((processed_frames / total_frames) * 60)
            progress_callback(video_id, f"Tagueando frames ({processed_frames}/{total_frames})...", progress)
        except Exception as e:
            print(f"Erro ao processar lote de tags: {e}")
            continue
            
    return results

def calcular_similaridade_jaccard(tags1, tags2):
    set1, set2 = set(tags1.keys()), set(tags2.keys()); intersecao = set1.intersection(set2); uniao = set1.union(set2)
    return len(intersecao) / len(uniao) if uniao else 1.0

def detectar_trocas_de_cena(dados_tags, fps, limiar_similaridade):
    frames_ordenados = sorted(dados_tags.keys(), key=lambda x: int(re.search(r'(\d+)', x).group(1)))
    trocas_de_cena = [0.0]
    for i in range(len(frames_ordenados) - 1):
        similaridade = calcular_similaridade_jaccard(dados_tags[frames_ordenados[i]], dados_tags[frames_ordenados[i+1]])
        if similaridade < limiar_similaridade:
            trocas_de_cena.append((i + 1) / fps)
    return trocas_de_cena, frames_ordenados

def agrupar_cenas_com_tags(trocas_de_cena, frames_ordenados, dados_tags, fps, video_duration):
    cenas_agrupadas = []; trocas_de_cena.append(video_duration)
    for i in range(len(trocas_de_cena) - 1):
        start_time, end_time = trocas_de_cena[i], trocas_de_cena[i+1]
        start_frame_idx = int(start_time * fps)
        end_frame_idx = min(int(end_time * fps), len(frames_ordenados))
        frames_da_cena = frames_ordenados[start_frame_idx:end_frame_idx]
        tags_agregadas = {}; [tags_agregadas.setdefault(tag, []).append(score) for frame_nome in frames_da_cena for tag, score in dados_tags.get(frame_nome, {}).items()]
        tags_medias = {tag: np.mean(scores) for tag, scores in tags_agregadas.items()}
        tags_principais = sorted(tags_medias.items(), key=lambda item: item[1], reverse=True)
        cenas_agrupadas.append({
            "cena_n": i + 1,
            "start_time": round(start_time, 3),
            "end_time": round(end_time, 3),
            "duration": round(end_time - start_time, 3),
            "tags_principais": {tag.replace(' ', '_'): round(score, 3) for tag, score in tags_principais}
        })
    return cenas_agrupadas

# ==============================================================================
# --- FUNÇÃO ORQUESTRADORA PRINCIPAL ---
# ==============================================================================

def run_video_processing_pipeline(video_path, fps, similarity_threshold, batch_size, video_id, progress_callback):
    """
    Função completa que executa todo o pipeline para um vídeo.
    Retorna os dados das cenas ou levanta uma exceção em caso de erro.
    """
    global PREDICTOR_GLOBAL
    
    # 1. Carrega o modelo de IA na primeira vez que for necessário
    if PREDICTOR_GLOBAL is None:
        progress_callback(video_id, "Carregando modelo de IA (só na 1ª vez)...", 2)
        PREDICTOR_GLOBAL = Predictor()
        PREDICTOR_GLOBAL.load_model()

    temp_frames_path = os.path.join("web", "temp_frames", str(video_id))
    
    try:
        # 2. Extrai Frames
        num_frames = extrair_frames(video_path, temp_frames_path, fps, video_id, progress_callback)
        if num_frames == 0:
            raise Exception("Extração de frames falhou ou não gerou frames.")

        # 3. Gera Tags
        dados_tags = gerar_tags_para_frames(PREDICTOR_GLOBAL, temp_frames_path, num_frames, batch_size, video_id, progress_callback)
        if dados_tags is None:
            raise Exception("Geração de tags falhou.")
        
        # 4. Detecta Cenas
        progress_callback(video_id, "Detectando mudanças de cena...", 85)
        ffprobe_cmd = ['ffprobe', '-v', 'error', '-show_entries', 'format=duration', '-of', 'default=noprint_wrappers=1:nokey=1', video_path]
        video_duration = float(subprocess.check_output(ffprobe_cmd).strip())
        
        trocas_de_cena, frames_ordenados = detectar_trocas_de_cena(dados_tags, fps, similarity_threshold)
        cenas_agrupadas = agrupar_cenas_com_tags(trocas_de_cena, frames_ordenados, dados_tags, fps, video_duration)
        
        return cenas_agrupadas
        
    finally:
        # 5. Limpeza da pasta temporária
        if os.path.exists(temp_frames_path):
            shutil.rmtree(temp_frames_path)

--------

#.\web\home.js

/**
 * Manipula a lógica da tela inicial (home.html).
 */
document.addEventListener('DOMContentLoaded', async () => {
    const buttonsContainer = document.getElementById('actress-buttons');
    const mainArt = document.getElementById('main-art');
    const mainArtVideo = document.getElementById('main-art-video');
    
    // Mostra um feedback de carregamento
    buttonsContainer.innerHTML = '<p class="loading-text">Carregando atrizes...</p>';

    // Busca a lista de atrizes no backend Python
    const actresses = await eel.get_all_actresses()();
    
    // Limpa a mensagem de carregamento
    buttonsContainer.innerHTML = '';

    if (actresses && actresses.length > 0) {
        // Define a arte principal com o vídeo da primeira atriz da lista
        // (usando um vídeo como fundo é mais dinâmico que uma imagem)
        mainArtVideo.src = actresses[0].file_path;
        mainArtVideo.play();

        // Cria um botão para cada atriz
        actresses.forEach(actress => {
            const button = document.createElement('button');
            button.className = 'actress-btn';
            button.innerText = actress.actress;

            // Define a ação de clique para navegar para a galeria
            button.onclick = () => viewActressGallery(actress.actress);
            
            // Bônus: muda o vídeo de fundo ao passar o mouse sobre o botão
            button.onmouseover = () => {
                if (mainArtVideo.src !== actress.file_path) {
                    mainArtVideo.src = actress.file_path;
                    mainArtVideo.play();
                }
            };
            buttonsContainer.appendChild(button);
        });
    } else {
        buttonsContainer.innerHTML = '<p class="loading-text">Nenhuma atriz encontrada no banco de dados.</p>';
    }
});

/**
 * Navega para a página da galeria, usando um caminho absoluto a partir da raiz do servidor.
 * @param {string} actressName - O nome da atriz selecionada */
function viewActressGallery(actressName) {
    const encodedName = encodeURIComponent(actressName);
    
    // [CONFIGURAÇÃO FINAL E CORRETA]
    // Como a raiz do servidor é a pasta 'web', o caminho para a galeria é simplesmente 'gallery.html'
    window.location.href = `gallery.html?actress=${encodedName}`;
}

--------

#.\web\home_style.css

body, html {
    margin: 0; padding: 0; width: 100%; height: 100%;
    overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif;
}
.splash-container {
    width: 100%; height: 100%; position: relative;
}
.background-video {
    position: absolute; top: 50%; left: 50%;
    width: 100%; height: 100%;
    object-fit: cover;
    transform: translate(-50%, -50%);
    z-index: -1;
    filter: brightness(0.4);
}
.main-content {
    width: 100%; height: 100%;
    display: flex; flex-direction: column;
    justify-content: center; align-items: center;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(5px);
}
.art-container {
    text-align: center;
    margin-bottom: 30px;
}
.title {
    color: white; font-size: 5em; font-weight: 900;
    text-shadow: 3px 3px 10px rgba(0, 0, 0, 0.9);
    margin: 0; letter-spacing: 2px;
}
.buttons-container {
    display: flex; flex-wrap: wrap; justify-content: center;
    gap: 15px; max-width: 80%;
}
.actress-btn {
    background-color: rgba(187, 134, 252, 0.8);
    color: #fff; border: 1px solid rgba(255, 255, 255, 0.5);
    padding: 15px 30px; font-size: 1.1em; font-weight: bold;
    border-radius: 8px; cursor: pointer;
    transition: transform 0.2s ease, background-color 0.2s ease, box-shadow 0.2s ease;
}
.actress-btn:hover {
    transform: scale(1.05);
    background-color: #bb86fc;
    box-shadow: 0 0 15px rgba(187, 134, 252, 0.7);
}
.loading-text { color: #fff; font-size: 1.2em; }

--------

#.\web\script.js

// --- ESTADO DA APLICAÇÃO ---
let currentPage = 1;
let totalPages = 1;
let currentActressName = '';
let currentSearchQuery = '';
let currentSearchTag = null;
let isFetching = false;
const sceneColors = ['#3498db', '#e74c3c', '#2ecc71', '#f1c40f', '#9b59b6', '#1abc9c', '#e67e22', '#f39c12'];
let videoDataCache = {};
let allAutocompleteTags = [];

// --- FUNÇÕES DE RENDERIZAÇÃO E LÓGICA PRINCIPAL ---
function renderGallery(response, isSearchResult = false) {
    const gallery = document.getElementById('video-gallery');
    
    // Apenas limpa a galeria para uma nova busca ou na primeira página
    if (isSearchResult && currentPage === 1) {
        gallery.innerHTML = '';
    } else if (!isSearchResult && currentPage === 1) {
        gallery.innerHTML = '';
    }

    currentSearchQuery = isSearchResult ? response.search_query : '';
    currentSearchTag = isSearchResult ? response.highlight_tag : null;

    document.getElementById('pagination-controls').style.display = isSearchResult || response.videos.length === 0 ? 'none' : 'block';
    document.getElementById('clear-button').style.display = isSearchResult ? 'inline-block' : 'none';

    if (response.error) { gallery.innerHTML = `<h2 style="color:red;">${response.error}</h2>`; return; }

    if (!isSearchResult) {
        currentPage = response.currentPage;
        totalPages = response.totalPages;
        updatePaginationControls();
    }

    if (response.videos.length === 0 && currentPage === 1) {
        gallery.innerHTML = isSearchResult ? `<h2>Nenhum vídeo encontrado para "${response.search_query}".</h2>` : '<h2>Nenhum vídeo encontrado para esta atriz.</h2>';
        return;
    }

    response.videos.forEach(video => {
        const videoCard = document.createElement('div');
        videoCard.className = 'video-card';
        videoCard.id = `card-${video.video_id}`;
        
        if (video.has_scenes) {
            videoCard.innerHTML = renderProcessedCard(video);
        } else {
            videoCard.innerHTML = renderUnprocessedCard(video);
        }
        
        gallery.appendChild(videoCard);

        if (video.has_scenes) {
            videoCard.querySelector('video').src = video.file_path;
            addEventListenersToVideo(video.video_id, response.highlight_tag);
        }
    });
}

function renderProcessedCard(video) {
    let tagsHtml = '<div class="tags-container">';
    if (video.main_tags) {
        video.main_tags.split('|||').forEach(tagWithScore => {
            const [tagName, score] = tagWithScore.split(':');
            tagsHtml += `<span class="tag" title="Confiança: ${score}" onclick="toggleTagFilter(${video.video_id}, '${tagName}')">${tagName}</span>`;
        });
    }
    tagsHtml += '</div>';

    return `
        <video id="video-${video.video_id}" preload="metadata" controls loop muted></video>
        <div id="progress-container-${video.video_id}" class="custom-progress-bar-container">
            <div id="scene-bar-${video.video_id}" class="scene-progress-bar"></div>
            <div id="playhead-${video.video_id}" class="playhead"></div>
        </div>
        <div class="video-info">
            <div class="card-header">
                <h3>${video.video_name}</h3>
                <button class="next-scene-btn" onclick="startProcessing(${video.video_id}, true)">Refazer</button>
            </div>
            ${tagsHtml}
        </div>
        <div id="processing-overlay-${video.video_id}" class="processing-overlay">
            <div class="progress-bar-container">
                <div id="progress-fill-${video.video_id}" class="progress-bar-fill"></div>
            </div>
            <p id="progress-status-${video.video_id}">Iniciando...</p>
        </div>
    `;
}

function renderUnprocessedCard(video) {
    return `
        <div class="unprocessed-card">
            <video class="video-thumbnail" src="${video.file_path}" preload="metadata" muted></video>
            <button class="process-btn" onclick="startProcessing(${video.video_id})">Analisar Cenas</button>
        </div>
        <div class="video-info">
            <div class="card-header">
                <h3>${video.video_name}</h3>
            </div>
        </div>
        <div id="processing-overlay-${video.video_id}" class="processing-overlay">
            <div class="progress-bar-container">
                <div id="progress-fill-${video.video_id}" class="progress-bar-fill"></div>
            </div>
            <p id="progress-status-${video.video_id}">Iniciando...</p>
        </div>
    `;
}

// --- LÓGICA DE PROCESSAMENTO (CHAMADA PELOS BOTÕES) ---
function startProcessing(videoId, isRemake = false) {
    const overlay = document.getElementById(`processing-overlay-${videoId}`);
    if (overlay) {
        overlay.classList.add('visible');
    }
    update_process_status(videoId, "Enviando para o backend...", 1);
    eel.process_video(videoId, 1.0, 0.4, 32);
}

// --- FUNÇÕES EXPOSTAS AO PYTHON (CALLBACKS) ---
eel.expose(update_process_status, 'update_process_status');
function update_process_status(videoId, status, progress) {
    const statusText = document.getElementById(`progress-status-${videoId}`);
    const progressBarFill = document.getElementById(`progress-fill-${videoId}`);
    
    if (statusText) statusText.textContent = status;
    if (progressBarFill) {
        if (progress === -1) {
            progressBarFill.style.width = '100%';
            progressBarFill.style.backgroundColor = '#e74c3c';
        } else {
            progressBarFill.style.width = `${progress}%`;
            progressBarFill.style.backgroundColor = '#bb86fc';
        }
    }
}

eel.expose(process_finished, 'process_finished');
async function process_finished(videoId, success) {
    if (success) {
        // Recarrega a página atual para refletir as mudanças
        if (currentSearchQuery) {
            performSearch(currentPage);
        } else {
            loadVideos(currentPage);
        }
    } else {
        setTimeout(() => {
            const overlay = document.getElementById(`processing-overlay-${videoId}`);
            if (overlay) overlay.classList.remove('visible');
        }, 5000);
    }
}

// --- LÓGICA DE BUSCA, PLAYER E NAVEGAÇÃO ---
function jumpToNextScene(videoId) {
    const videoElement = document.getElementById(`video-${videoId}`);
    const scenes = videoDataCache[videoId]?.scenes;
    if (!videoElement || !scenes || scenes.length === 0) return;
    const currentTime = videoElement.currentTime;
    let targetScenes = scenes;
    if (currentSearchTag) {
        targetScenes = scenes.filter(scene => scene.tags && scene.tags.split(',').includes(currentSearchTag));
        const btn = videoElement.closest('.video-card').querySelector('.next-scene-btn');
        if (btn) btn.innerHTML = `Próxima com "${currentSearchTag}" &raquo;`;
    }
    if (targetScenes.length === 0) return;
    let nextScene = targetScenes.find(scene => scene.start_time > currentTime + 0.1);
    if (!nextScene) nextScene = targetScenes[0];
    videoElement.currentTime = nextScene.start_time;
    videoElement.play();
}

async function performSearch(page = 1) {
    if (page === 1) {
        currentSearchQuery = document.getElementById('search-input').value;
        currentPage = 1; // Reseta a página para uma nova busca
        document.getElementById('video-gallery').innerHTML = `<h2>Buscando por "${currentSearchQuery}"...</h2>`;
    }
    if (!currentSearchQuery.trim() || isFetching) return;
    isFetching = true;
    const response = await eel.search_videos_by_tags(currentActressName, currentSearchQuery, page)();
    renderGallery(response, true);
    isFetching = false;
}

function setupAutocomplete(input, tags) { /* ...código completo do autocomplete... */ }
async function loadVideos(page) {
    isFetching = true;
    const response = await eel.get_videos_page(currentActressName, page)();
    renderGallery(response, false);
    isFetching = false;
}

function addEventListenersToVideo(videoId, highlightTag = null) {
    const videoElement = document.getElementById(`video-${videoId}`);
    const progressContainer = document.getElementById(`progress-container-${videoId}`);
    const playhead = document.getElementById(`playhead-${videoId}`);
    videoElement.addEventListener('loadedmetadata', async () => {
        const scenes = await eel.get_scenes_for_video(videoId)();
        videoDataCache[videoId].scenes = scenes;
        if (highlightTag) {
            setTimeout(() => toggleTagFilter(videoId, highlightTag), 100);
        } else {
            drawSceneBar(videoId, videoElement.duration);
        }
    });
    videoElement.addEventListener('timeupdate', () => {
        if (!videoElement.duration) return;
        const progressPercent = (videoElement.currentTime / videoElement.duration) * 100;
        playhead.style.left = `${progressPercent}%`;
    });
    progressContainer.addEventListener('click', (e) => {
        const rect = progressContainer.getBoundingClientRect();
        videoElement.currentTime = ((e.clientX - rect.left) / progressContainer.offsetWidth) * videoElement.duration;
    });
}

function toggleTagFilter(videoId, clickedTag) {
    const videoData = videoDataCache[videoId];
    const videoElement = document.getElementById(`video-${videoId}`);
    videoData.activeTag = (videoData.activeTag === clickedTag) ? null : clickedTag;
    const card = videoElement.closest('.video-card');
    card.querySelectorAll('.tag').forEach(tagEl => {
        tagEl.classList.toggle('active', tagEl.innerText === videoData.activeTag);
    });
    drawSceneBar(videoId, videoElement.duration, videoData.activeTag);
}

function drawSceneBar(videoId, totalDuration, filterTag = null) {
    const sceneBar = document.getElementById(`scene-bar-${videoId}`);
    const scenes = videoDataCache[videoId].scenes;
    if (!scenes) return;
    sceneBar.innerHTML = '';
    scenes.forEach((scene, index) => {
        const segment = document.createElement('div');
        segment.className = 'scene-segment';
        const segmentDuration = scene.end_time - scene.start_time;
        const segmentWidth = (segmentDuration / totalDuration) * 100;
        if (filterTag && (!scene.tags || !scene.tags.split(',').includes(filterTag))) {
            segment.classList.add('faded');
        }
        segment.style.width = `${segmentWidth}%`;
        segment.style.backgroundColor = sceneColors[index % sceneColors.length];
        segment.title = `Cena ${index + 1}: ${scene.start_time.toFixed(1)}s - ${scene.end_time.toFixed(1)}s [${scene.tags || ''}]`;
        sceneBar.appendChild(segment);
    });
}

function updatePaginationControls() {
    document.getElementById('page-info').textContent = `Página ${currentPage} de ${totalPages}`;
    document.getElementById('prev-button').disabled = (currentPage <= 1);
    document.getElementById('next-button').disabled = (currentPage >= totalPages);
}

// --- INICIALIZAÇÃO E EVENTOS GLOBAIS ---
document.addEventListener('DOMContentLoaded', async () => {
    // ... (código de inicialização anterior)
    const params = new URLSearchParams(window.location.search);
    currentActressName = decodeURIComponent(params.get('actress'));
    if (!currentActressName || currentActressName === 'null') {
        document.body.innerHTML = '<h1>ERRO: Nenhuma atriz especificada.</h1>'; return;
    }
    document.querySelector('h1').innerText = `Galeria de Cenas: ${currentActressName}`;
    document.title = `Galeria: ${currentActressName}`;
    const tagsJson = await eel.get_all_tags_for_autocomplete()();
    allAutocompleteTags = JSON.parse(tagsJson);
    setupAutocomplete(document.getElementById("search-input"), allAutocompleteTags);
    document.getElementById('search-button').addEventListener('click', () => performSearch(1));
    document.getElementById('search-input').addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); performSearch(1); } });
    document.getElementById('clear-button').addEventListener('click', () => { document.getElementById('search-input').value = ''; currentSearchQuery = ''; loadVideos(1); });
    document.getElementById('prev-button').addEventListener('click', () => { if (currentPage > 1) loadVideos(currentPage - 1); });
    document.getElementById('next-button').addEventListener('click', () => { if (currentPage < totalPages) loadVideos(currentPage + 1); });
    loadVideos(1);
});

// Lógica de scroll infinito
window.onscroll = () => {
    if (isFetching || currentPage >= totalPages) return;
    if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 500) {
        if (currentSearchQuery) {
            performSearch(currentPage + 1);
        } else {
            loadVideos(currentPage + 1);
        }
    }
};

// Cole a função setupAutocomplete completa aqui se precisar.
function setupAutocomplete(input, tags) {let currentFocus;input.addEventListener("input",function(e){let a,b,i,val=this.value;closeAllLists();if(!val)return false;currentFocus=-1;a=document.createElement("DIV");a.setAttribute("id",this.id+"autocomplete-list");a.setAttribute("class","autocomplete-items");this.parentNode.appendChild(a);const lastTokenIndex=val.lastIndexOf(' ')+1;const lastToken=val.substring(lastTokenIndex).toLowerCase();if(!lastToken)return;for(i=0;i<tags.length;i++){if(tags[i].substr(0,lastToken.length).toLowerCase()==lastToken){b=document.createElement("DIV");b.innerHTML="<strong>"+tags[i].substr(0,lastToken.length)+"</strong>";b.innerHTML+=tags[i].substr(lastToken.length);b.innerHTML+="<input type='hidden' value='"+tags[i]+"'>";b.addEventListener("click",function(e){const base=val.substring(0,lastTokenIndex);const tagToAdd=this.getElementsByTagName("input")[0].value;const finalTag=tagToAdd.includes(' ')?`"${tagToAdd}"`:tagToAdd;input.value=base+finalTag+' ';closeAllLists();input.focus();});a.appendChild(b);}}});input.addEventListener("keydown",function(e){let x=document.getElementById(this.id+"autocomplete-list");if(x)x=x.getElementsByTagName("div");if(e.keyCode==40){currentFocus++;addActive(x);}else if(e.keyCode==38){currentFocus--;addActive(x);}else if(e.keyCode==13){if(currentFocus>-1){if(x)x[currentFocus].click();}}});function addActive(x){if(!x)return false;removeActive(x);if(currentFocus>=x.length)currentFocus=0;if(currentFocus<0)currentFocus=x.length-1;x[currentFocus].classList.add("autocomplete-active");}function removeActive(x){for(var i=0;i<x.length;i++){x[i].classList.remove("autocomplete-active");}}function closeAllLists(elmnt){var x=document.getElementsByClassName("autocomplete-items");for(var i=0;i<x.length;i++){if(elmnt!=x[i]&&elmnt!=input){x[i].parentNode.removeChild(x[i]);}}}document.addEventListener("click",function(e){closeAllLists(e.target);});}

--------

#.\web\style.css

/* Estilos Gerais */
body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background-color: #121212;
    color: #e0e0e0;
    margin: 0;
    padding: 20px;
}
.container {
    max-width: 95%;
    margin: auto;
}
h1 {
    text-align: center;
    color: #bb86fc;
    border-bottom: 2px solid #333;
    padding-bottom: 10px;
    margin-bottom: 20px;
}

/* Barra de Busca */
.search-bar {
    position: relative;
    display: flex;
    justify-content: center;
    margin-bottom: 25px;
    gap: 10px;
}
#search-input {
    width: 50%;
    padding: 10px 15px;
    font-size: 1em;
    border: 1px solid #555;
    border-radius: 5px;
    background-color: #2a2a2a;
    color: #fff;
}
.search-bar button {
    background-color: #bb86fc;
    border: none;
    color: #121212;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
}
#clear-button {
    background-color: #444;
    color: #fff;
}

/* Autocomplete */
.autocomplete-items {
    position: absolute;
    border: 1px solid #333;
    border-top: none;
    z-index: 99;
    top: 100%;
    left: 20.5%;
    right: 20.5%;
    max-height: 200px;
    overflow-y: auto;
}
.autocomplete-items div {
    padding: 10px;
    cursor: pointer;
    background-color: #2a2a2a;
    border-bottom: 1px solid #333;
    color: #fff;
}
.autocomplete-items div:hover {
    background-color: #444;
}
.autocomplete-active {
    background-color: #bb86fc !important;
    color: #121212 !important;
}

/* Galeria de Vídeos */
.gallery-container {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
    gap: 25px;
}
.video-card {
    background-color: #1e1e1e;
    border: 1px solid #333;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    display: flex;
    flex-direction: column;
}
.video-card video {
    width: 100%;
    display: block;
    background-color: #000;
}
.video-info {
    padding: 10px 15px;
}

/* [NOVO] Cabeçalho do Card (Título + Botão Próxima Cena) */
.card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px; /* Espaço entre o header e as tags */
}
.card-header h3 {
    margin: 0;
    font-size: 1.1em;
    color: #fff;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex-grow: 1;
}
.next-scene-btn {
    background-color: #3a3b3c;
    color: #e4e6eb;
    border: 1px solid #555;
    padding: 5px 12px;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    font-size: 0.8em;
    white-space: nowrap;
    transition: background-color 0.2s;
    flex-shrink: 0; /* Impede que o botão encolha */
}
.next-scene-btn:hover {
    background-color: #4e4f50;
}

/* Barra de Cenas Customizada */
.custom-progress-bar-container {
    position: relative;
    width: 100%;
    height: 15px;
    cursor: pointer;
    background-color: #333;
}
.scene-progress-bar {
    display: flex;
    width: 100%;
    height: 100%;
}
.scene-segment {
    height: 100%;
    transition: opacity 0.3s ease-in-out;
}
.scene-segment.faded {
    opacity: 0.2;
}
.scene-segment:not(.faded):hover {
    filter: brightness(1.2);
    transform: scaleY(1.1);
}
.playhead {
    position: absolute;
    top: 0;
    left: 0;
    width: 2px;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.8);
    pointer-events: none;
}

/* Tags Interativas */
.tags-container {
    padding-top: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    max-height: 4.2em; 
    overflow-y: auto;  
    padding-right: 5px; 
}
.tag {
    background-color: #3a3b3c;
    color: #e4e6eb;
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 0.85em;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s, color 0.2s;
    border: 1px solid transparent;
}
.tag:hover {
    background-color: #4e4f50;
}
.tag.active {
    background-color: #bb86fc;
    color: #121212;
    border-color: #fff;
}

/* Barra de Rolagem das Tags */
.tags-container::-webkit-scrollbar { width: 8px; }
.tags-container::-webkit-scrollbar-track { background: #2a2a2a; border-radius: 4px; }
.tags-container::-webkit-scrollbar-thumb { background-color: #555; border-radius: 4px; border: 2px solid #2a2a2a; }
.tags-container::-webkit-scrollbar-thumb:hover { background-color: #777; }

/* Paginação */
.pagination {
    text-align: center;
    margin-top: 30px;
}
.pagination button {
    background-color: #bb86fc;
    border: none;
    color: #121212;
    padding: 10px 20px;
    margin: 0 10px;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    transition: background-color 0.2s;
}
.pagination button:hover {
    background-color: #9f52f7;
}
.pagination button:disabled {
    background-color: #555;
    cursor: not-allowed;
}
#page-info {
    font-size: 1.1em;
    vertical-align: middle;
}

.unprocessed-card {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 215px; /* Altura aproximada de um player de vídeo */
    background-color: #2a2a2a;
    position: relative;
    overflow: hidden;
}

.unprocessed-card .video-thumbnail {
    width: 100%;
    height: 100%;
    object-fit: cover;
    filter: brightness(0.4) blur(2px);
    position: absolute;
    top: 0;
    left: 0;
}

.process-btn {
    background-color: #bb86fc;
    color: #121212;
    border: 2px solid rgba(255, 255, 255, 0.8);
    padding: 12px 25px;
    font-size: 1.1em;
    font-weight: bold;
    border-radius: 8px;
    cursor: pointer;
    z-index: 2;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.process-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 15px rgba(187, 134, 252, 0.7);
}

/* --- [NOVO] Estilos para o Feedback de Processamento --- */
.processing-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(5px);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: #fff;
    z-index: 3;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}

.processing-overlay.visible {
    opacity: 1;
    pointer-events: all;
}

.processing-overlay p {
    margin-top: 15px;
    font-size: 1.1em;
}

.progress-bar-container {
    width: 80%;
    height: 20px;
    background-color: #333;
    border-radius: 10px;
    overflow: hidden;
    border: 1px solid #555;
}

.progress-bar-fill {
    width: 0%;
    height: 100%;
    background-color: #bb86fc;
    border-radius: 10px;
    transition: width 0.2s ease-out;
}

--------

